#lang racket/base

(require racket/unsafe/ops)
(require rackunit)

;(require data/bit-vector)  ;; too slow

;; up-bound is non-inclusive
(define (run-sieve up-bound)
  (define bstring (make-bytes up-bound 1))

  (unsafe-bytes-set! bstring 0 0)
  (unsafe-bytes-set! bstring 1 0)

  ;; mark even numbers after 2 so we can skip all even numbers in the for loop below
  (for ([i (in-range 4 up-bound 2)])
    (unsafe-bytes-set! bstring i 0))
  
  (for ([i (in-range 3 (sqrt up-bound) 2)])
    (when (unsafe-fx= (unsafe-bytes-ref bstring i)
                      1)
      (for ([multiple (in-range (* i i) up-bound (* i 2))])
        (unsafe-bytes-set! bstring multiple 0))))

  bstring)

;; not significantly faster than the for loop version
(define (run-sieve/loop up-bound)
  (define bstring (make-bytes up-bound 1))

  (unsafe-bytes-set! bstring 0 0)
  (unsafe-bytes-set! bstring 1 0)

  ;; mark even numbers after 2 so we can skip all even numbers in the for loop below
  (let loop ([i 4])
    (when (unsafe-fx< i up-bound)
      (unsafe-bytes-set! bstring i 0)
      (loop (unsafe-fx+ i 2))))

  (define up-bound-sqrt (sqrt up-bound))
  (let loop ([i 3])
    (when (unsafe-fx< i up-bound-sqrt)
      (when (unsafe-fx= (unsafe-bytes-ref bstring i)
                        1)
        (define i-times-two (unsafe-fx* i 2))
        (let loop2 ([multiple (unsafe-fx* i i)])
          (when (unsafe-fx< multiple up-bound)
            (unsafe-bytes-set! bstring multiple 0)
            (loop2 (unsafe-fx+ multiple i-times-two)))))
      (loop (unsafe-fx+ i 2))))

  bstring)
  
;; get a list of prime numbers from the byte string generated by run-sieve
(define (primes bstring)
  (cons 2 
        ;; skip indices 0-2 and even indexes since we know even numbers are not prime
        (for/list ([i (in-range 3 (bytes-length bstring) 2)]
                   [val (in-bytes bstring 3 #f 2)]
                   #:when (equal? val 1))
          i)))


;; implementation using vectors
;; up-bound is non-inclusive
(define (run-sieve/vector up-bound)
  (define pvec (make-vector up-bound #t))

  ;; mark even numbers after 2 so we can skip all even numbers in the for loop below
  (for ([i (in-range 4 up-bound 2)])
    (unsafe-vector-set! pvec i #f))

  ;; start at 3 and skip even numbers
  (for ([i (in-range 3 (sqrt up-bound) 2)])
    (when (unsafe-vector-ref pvec i)
      ;; mark all multiples of prime number i as non-prime
      (for ([multiple (in-range (* i i) up-bound (* i 2))])
        (unsafe-vector-set! pvec multiple #f))))

  pvec)

(define (primes/vector pvec)
  (cons 2 
        ;; skip indices 0-2 and even indexes since we know even numbers are not prime
        (for/list ([i (in-range 3 (vector-length pvec) 2)]
                   [prime? (in-vector pvec 3 #f 2)]
             #:when prime?)
    i)))


(define (measure-perf sieve-func up-bound seconds)
  (define start-time (current-milliseconds))
  (define end-time (+ start-time (* seconds 1000)))
  
  (let loop ([passes 0])
    (sieve-func up-bound)
    (if (< (current-milliseconds) end-time)
        (loop (add1 passes))
        (printf "Completed ~a passes~n" passes))))


(define (validate-results)
  (printf "Validating main implementation~n")
  (check-equal? (length (primes (run-sieve 10))) 4)
  (check-equal? (length (primes (run-sieve 100))) 25)
  (check-equal? (length (primes (run-sieve 1000))) 168)
  (check-equal? (length (primes (run-sieve 10000))) 1229)
  (check-equal? (length (primes (run-sieve 100000))) 9592)
  (check-equal? (length (primes (run-sieve 1000000))) 78498)
  (check-equal? (length (primes (run-sieve 10000000))) 664579)
  (check-equal? (length (primes (run-sieve 100000000))) 5761455)
  (printf "..done~n")
#|
  (printf "Validating bytes loop implementation~n")
  (check-equal? (length (primes (run-sieve/loop 10))) 4)
  (check-equal? (length (primes (run-sieve/loop 100))) 25)
  (check-equal? (length (primes (run-sieve/loop 1000))) 168)
  (check-equal? (length (primes (run-sieve/loop 10000))) 1229)
  (check-equal? (length (primes (run-sieve/loop 100000))) 9592)
  (check-equal? (length (primes (run-sieve/loop 1000000))) 78498)
  (check-equal? (length (primes (run-sieve/loop 10000000))) 664579)
  (check-equal? (length (primes (run-sieve/loop 100000000))) 5761455)
  (printf "..done~n")
|#
  (printf "Validating vector implementation~n")
  (check-equal? (length (primes/vector (run-sieve/vector 10))) 4)
  (check-equal? (length (primes/vector (run-sieve/vector 100))) 25)
  (check-equal? (length (primes/vector (run-sieve/vector 1000))) 168)
  (check-equal? (length (primes/vector (run-sieve/vector 10000))) 1229)
  (check-equal? (length (primes/vector (run-sieve/vector 100000))) 9592)
  (check-equal? (length (primes/vector (run-sieve/vector 1000000))) 78498)
  (check-equal? (length (primes/vector (run-sieve/vector 10000000))) 664579)
  (check-equal? (length (primes/vector (run-sieve/vector 100000000))) 5761455)
  (printf "..done~n"))

(module+ main
  (validate-results)
  ;; run garbage collector to prevent GC from the validation to slow down the test
  (collect-garbage 'major)
  (collect-garbage 'major)
  (time (measure-perf run-sieve 1000000 5)))
